{"version":3,"file":"static/chunks/pages/hsp-89b77ba059908dd2.js","mappings":"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","sources":["webpack://_N_E/?eb80","webpack://_N_E/./modules/hsp/spatial-hash.ts","webpack://_N_E/./modules/hsp/index.ts","webpack://_N_E/./pages/hsp/index.tsx","webpack://_N_E/./pages/hsp/hsp_page_style.module.css"],"sourcesContent":["\n    (window.__NEXT_P = window.__NEXT_P || []).push([\n      \"/hsp\",\n      function () {\n        return require(\"private-next-pages/hsp/index.tsx\");\n      }\n    ]);\n    if(module.hot) {\n      module.hot.dispose(function () {\n        window.__NEXT_P.push([\"/hsp\"])\n      });\n    }\n  ","// basically this is gridSize but it's the same for every subdivision level for now\n// it affects how condensed cell will become\n// it is maximum amount of hashtable entries that can be taken by all objects\n// e.g. if we have 100 objects and M = 10 then AT BEST each cell will contain 10 objects\n// in reality density of the cell depends on how much collision hash function have\n// as well as if objects are overlapping in space\nconst M = 100000\n\nexport class Rectangle {\n    x: number\n    y: number\n    width: number\n    height: number\n}\n\nexport interface SpatialHashObject {\n    level: number\n    hash: number\n    getBoundingBox(): Rectangle\n}\n\nfunction testPointInBounds(x: number, y: number, b: Rectangle): boolean {\n    return x < b.x + b.width && y < b.y + b.height && x >= b.x && y >= b.y\n}\n\nfunction djb2Hash(x: number, y: number, l: number): number {\n    let hash = 5381\n\n    hash = hash * 33 + x\n    hash = hash * 33 + y\n    hash = hash * 33 + l\n\n    return hash % M\n}\n\nfunction getHash(x: number, y: number, level: number, dx: number = 0, dy: number = 0): number {\n    // k \n    // Equation 3\n    const invCellSize = 1 / (2 ** level)\n\n    // here we converting world to grid space\n    // Equation 1\n    const cellX = Math.floor(x * invCellSize) + dx\n    const cellY = Math.floor(y * invCellSize) + dy\n\n    return djb2Hash(cellX, cellY, level)\n}\n\nfunction getSubdivisonLevel(width: number, height: number): number {\n    const longestEdge = Math.max(width, height)\n    // Equation 2\n    return Math.ceil(Math.log2(longestEdge))\n}\n\nexport class SpatialHash {\n    hashtable = new Map<number, SpatialHashObject[]>()\n    // we need to check every subdivision level so we better keep it\n    levels = new Map<number, number>()\n\n    addObject(obj: SpatialHashObject): void {\n        const bounds = obj.getBoundingBox()\n        const subdivisionLevel = getSubdivisonLevel(bounds.width, bounds.height)\n\n        const hash = getHash(bounds.x, bounds.y, subdivisionLevel)\n        let objects = this.hashtable.get(hash)\n        if (!objects) {\n            objects = []\n            this.hashtable.set(hash, objects)\n        }\n\n        obj.level = subdivisionLevel\n        obj.hash = hash\n        objects.push(obj)\n\n        const levelRefcount = this.levels.get(subdivisionLevel) || 0\n        this.levels.set(subdivisionLevel, levelRefcount + 1)\n    }\n\n    removeObject(obj: SpatialHashObject): void {\n        const hash = obj.hash\n\n        const objects = this.hashtable.get(hash)\n        \n        if (objects.length === 1) {\n            this.hashtable.delete(hash)\n        } else {\n            const index = objects.indexOf(obj)\n            objects.splice(index, 1)\n        }\n\n        const subdivisionLevel = obj.level\n        const levelRefcount = this.levels.get(subdivisionLevel)\n        if (levelRefcount > 1) {\n            this.levels.set(subdivisionLevel, levelRefcount - 1)\n        } else {\n            this.levels.delete(subdivisionLevel)\n        }\n\n        obj.level = undefined\n        obj.hash = undefined\n    }\n\n    updateObject(obj: SpatialHashObject): void {\n        const bounds = obj.getBoundingBox()\n\n        const level = obj.level\n        const newLevel = getSubdivisonLevel(bounds.width, bounds.height)\n\n        let shouldRefresh = newLevel !== level\n        if (!shouldRefresh) {\n            const hash = obj.hash\n            const newHash = getHash(bounds.x, bounds.y, newLevel)\n            shouldRefresh = hash !== newHash\n        }\n\n        if (shouldRefresh) {\n            this.removeObject(obj)\n            this.addObject(obj)\n        }\n    }\n\n    query(x: number, y: number): SpatialHashObject[] {\n        const result: SpatialHashObject[] = []\n\n        // since every object can only occupy 2x2 cells\n        // and every object is stored in top left cell out of those 2x2\n        // we must at most check 2x2 area going up and left\n        const offsets = [\n            -1, -1,\n            -1,  0,\n             0, -1,\n             0,  0,\n        ]\n\n        // for every subdivision level\n        for (const level of Array.from(this.levels.keys())) {\n            // we check current cell and 3 of top left neighboring cells (top, left, and diagonal top-left)\n            for (let i = 0; i < offsets.length; i += 2) {\n                const dx = offsets[i]\n                const dy = offsets[i + 1]\n\n                // board phase\n                const hash = getHash(x, y, level, dx, dy)\n                const objects = this.hashtable.get(hash)\n\n                // narrow phase\n                if (objects) {\n                    for (const obj of objects) {\n                        if (testPointInBounds(x, y, obj.getBoundingBox())) {\n                            result.push(obj)\n                        }\n                    }\n                }\n            }\n        }\n\n        return result\n    }\n}","import { Rectangle, SpatialHash, SpatialHashObject } from \"./spatial-hash\";\r\n\r\nfunction sfc32(a: number, b: number, c: number, d: number): () => number {\r\n    return function() {\r\n      a >>>= 0; b >>>= 0; c >>>= 0; d >>>= 0; \r\n      var t = (a + b) | 0;\r\n      a = b ^ b >>> 9;\r\n      b = c + (c << 3) | 0;\r\n      c = (c << 21 | c >>> 11);\r\n      d = d + 1 | 0;\r\n      t = t + d | 0;\r\n      c = c + t | 0;\r\n      return (t >>> 0) / 4294967296;\r\n    }\r\n}\r\n\r\nclass Sticker implements SpatialHashObject {\r\n    hash: number\r\n    level: number\r\n    \r\n    private bounds: Rectangle \r\n    constructor (public x: number, public y: number, \r\n        public width: number, public height: number,\r\n        public color: any, private renderer: SpatialHashRenderer) {\r\n        this.bounds = new Rectangle()\r\n    }\r\n\r\n    getBoundingBox(): Rectangle {\r\n        this.bounds.x = this.x\r\n        this.bounds.y = this.y\r\n        this.bounds.width = this.width\r\n        this.bounds.height = this.height\r\n\r\n        if (this.bounds.width < 0) {\r\n            this.bounds.width = -this.bounds.width\r\n            this.bounds.x += this.bounds.width\r\n        }\r\n\r\n        if (this.bounds.height < 0) {\r\n            this.bounds.height = -this.bounds.height\r\n            this.bounds.y += this.bounds.height\r\n        }\r\n\r\n        return this.bounds\r\n    }\r\n\r\n    getColorStr(): string {\r\n        const selected = this.renderer.selectedObjects.includes(this)\r\n        return selected ? 'rgba(255, 0, 0, 0.5)' : `rgba(${this.color.r}, ${this.color.g}, ${this.color.b}, 0.25)`\r\n    }\r\n}\r\n\r\ninterface SpatialHashRendererProps {\r\n    canvas: HTMLCanvasElement\r\n}\r\n\r\nexport class SpatialHashRenderer {\r\n    private mouseX: number\r\n    private mouseY: number\r\n\r\n    private canvas: HTMLCanvasElement\r\n    private context: CanvasRenderingContext2D\r\n\r\n    public selectedObjects: SpatialHashObject[] = []\r\n    private sh = new SpatialHash()\r\n    private objects: Sticker[] = []\r\n    private random = sfc32(0xDEADC0DE, 0xC3C3C3C3, 0xBEEFCAFE, 0xBAAAAAAD)\r\n\r\n    private rafHandle: number\r\n\r\n    private tickBind = this.tick.bind(this)\r\n\r\n    constructor (props: SpatialHashRendererProps) {\r\n        this.canvas = props.canvas\r\n        this.context = this.canvas.getContext('2d')\r\n\r\n        this.init()\r\n    }\r\n\r\n    private init() {\r\n        const { canvas, objects, sh } = this\r\n\r\n        canvas.width = canvas.clientWidth * devicePixelRatio\r\n        canvas.height = canvas.clientHeight * devicePixelRatio\r\n\r\n        // debugger\r\n\r\n        for (let i = 0; i < 15000; i++) {\r\n            this.addRandomObj()\r\n        }\r\n\r\n        this.canvas.onmousemove = e => {\r\n            this.mouseX = e.clientX * devicePixelRatio\r\n            this.mouseY = e.clientY * devicePixelRatio\r\n        }\r\n\r\n        this.rafHandle = requestAnimationFrame(this.tickBind)\r\n    }\r\n\r\n    private randomRange(min: number, max: number): number {\r\n        return min + this.random() * (max - min)\r\n    }\r\n\r\n    private draw() {\r\n        const { canvas, context, objects, sh } = this\r\n\r\n        context.fillStyle = 'black'\r\n        context.fillRect(0, 0, canvas.width, canvas.height)\r\n    \r\n        for (const obj of objects) {\r\n            const bounds = obj.getBoundingBox()\r\n            context.fillStyle = obj.getColorStr()\r\n            context.fillRect(bounds.x, bounds.y, bounds.width, bounds.height)\r\n        }\r\n    }\r\n\r\n    private changeObjects() {\r\n        for (const obj of this.objects) {\r\n            obj.x += this.randomRange(-30, 30)\r\n            obj.y += this.randomRange(-30, 30)\r\n            obj.width += this.randomRange(-30, 30)\r\n            obj.height += this.randomRange(-30, 30)\r\n        }\r\n    }\r\n\r\n    private updateSH() {\r\n        console.time('update objects (15k)')\r\n        for (const obj of this.objects) {\r\n            this.sh.updateObject(obj)\r\n        } \r\n        console.timeEnd('update objects (15k)')\r\n    }\r\n\r\n    private checkIntersections() {\r\n        console.time('query')\r\n        this.selectedObjects = this.sh.query(this.mouseX, this.mouseY)\r\n        console.timeEnd('query')\r\n    }\r\n\r\n    private addRandomObj() {\r\n        const canvas = this.canvas\r\n\r\n        const width = this.randomRange(5, 100)\r\n        const height = this.randomRange(5, 100)\r\n    \r\n        const x = this.randomRange(canvas.width * -15.02, canvas.width * 0.98 - width)\r\n        const y = this.randomRange(canvas.height * -15.02, canvas.height * 0.98 - height)\r\n    \r\n        const color = {\r\n            r: this.randomRange(0, 63),\r\n            g: this.randomRange(127, 255),\r\n            b: this.randomRange(127, 255)\r\n        }\r\n    \r\n        const sticker = new Sticker(x, y, width, height, color, this)\r\n        this.objects.push(sticker)\r\n\r\n        console.time('add object')\r\n        this.sh.addObject(sticker)\r\n        console.timeEnd('add object')\r\n    }\r\n    \r\n    private doRandomAddAndRemove() {\r\n        for (let i = 0; i < 100; i++) {\r\n            const index = Math.trunc(this.randomRange(0, this.objects.length - 1))\r\n            const obj = this.objects[index]\r\n            this.objects.splice(index, 1)\r\n\r\n            console.time('remove object')\r\n            this.sh.removeObject(obj)\r\n            console.timeEnd('remove object')\r\n\r\n            this.addRandomObj()\r\n        }\r\n    }\r\n\r\n    timer = 0\r\n\r\n    private tick() {\r\n        if (this.timer < 300) {\r\n            this.changeObjects()    \r\n            this.timer++\r\n        }\r\n        this.updateSH()\r\n        // this.doRandomAddAndRemove()\r\n        this.checkIntersections()\r\n\r\n        console.log('density: ' + Math.round(this.objects.length / this.sh.hashtable.size))\r\n        console.log('levels count: ' + this.sh.levels.size)\r\n\r\n        this.draw()\r\n\r\n        this.rafHandle = requestAnimationFrame(this.tickBind)\r\n    }\r\n\r\n    destroy () {\r\n        if (this.rafHandle) {\r\n            cancelAnimationFrame(this.rafHandle)\r\n            delete this.rafHandle\r\n        }\r\n        this.canvas.onmousemove = null\r\n    }\r\n}","/* eslint-disable jsx-a11y/alt-text */\n/* eslint-disable @next/next/no-img-element */\nimport type { NextPage } from 'next';\nimport React, { useEffect, useRef } from 'react';\nimport { SpatialHashRenderer } from '../../modules/hsp';\nimport styles from './hsp_page_style.module.css';\n\nconst HspAPI: NextPage = () => {\n    const canvasRef = useRef<HTMLCanvasElement>(null);\n    const rendererRef = useRef<SpatialHashRenderer>(null);\n\n\n    useEffect(() => {\n        if (!canvasRef.current) return;\n\n        rendererRef.current = new SpatialHashRenderer({\n            canvas: canvasRef.current,\n        });\n\n        return () => {\n            rendererRef.current.destroy();\n            rendererRef.current = null;\n        }\n    }, []);\n\n    return (\n        <div className={styles.scene}>\n            <canvas ref={canvasRef} className={styles.canvas} />\n        </div>\n    );\n};\n\nexport default HspAPI;\n","// extracted by mini-css-extract-plugin\nmodule.exports = {\"scene\":\"hsp_page_style_scene__r2Jwo\",\"canvas\":\"hsp_page_style_canvas__crqX6\",\"widgetInfo\":\"hsp_page_style_widgetInfo__RxEqM\",\"tweaks\":\"hsp_page_style_tweaks__8naFr\"};"],"names":["window","__NEXT_P","push","Rectangle","testPointInBounds","x","y","b","width","height","getHash","level","dx","dy","invCellSize","l","hash","djb2Hash","Math","floor","getSubdivisonLevel","longestEdge","max","ceil","log2","SpatialHash","hashtable","Map","levels","addObject","obj","bounds","getBoundingBox","subdivisionLevel","objects","this","get","set","levelRefcount","removeObject","length","delete","index","indexOf","splice","undefined","updateObject","newLevel","shouldRefresh","query","result","offsets","Array","from","keys","i","Sticker","color","renderer","getColorStr","selectedObjects","includes","r","g","SpatialHashRenderer","props","a","c","d","sh","random","t","tickBind","tick","bind","timer","canvas","context","getContext","init","clientWidth","devicePixelRatio","clientHeight","addRandomObj","onmousemove","e","mouseX","clientX","mouseY","clientY","rafHandle","requestAnimationFrame","randomRange","min","draw","fillStyle","fillRect","changeObjects","updateSH","console","time","timeEnd","checkIntersections","sticker","doRandomAddAndRemove","trunc","log","round","size","destroy","cancelAnimationFrame","canvasRef","useRef","rendererRef","useEffect","current","div","className","styles","ref","module","exports"],"sourceRoot":""}